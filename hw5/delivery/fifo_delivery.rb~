require 'rubygems'
require 'bud'
require 'delivery/delivery'

# Note that this provides at-least-once semantics. If you need exactly-once, the
# receiver-side can record the message IDs that have been received to avoid
# processing duplicate messages.
module FIFODelivery
  include DeliveryProtocol

  state do
    table :buffer, pipe_in.schema
    table :next_seqnos, [:src] => [:next_seqno]
    channel :pipe_talk, [:@dst, :src, :ident] => [:payload]
    scratch :pipe_chan, pipe_in.schema
    # channel :ack, [:@src, :dst, :ident]
    # scratch :msg_acked, buffer.schema
  end

  bloom :send do
    # pipe_talk <~ (buffer * next_seqnos).lefts(:src => :src,
    #                                           :ident => :next_seqno)
    pipe_talk <~ pipe_in
  end

  bloom :receive do
    buffer <= pipe_talk {|p| [p.dst, p.src, p.ident, p.payload]}

    next_seqnos <+ pipe_talk do |p|
      [p.src, 0] unless next_seqnos{|n| n.src}.include? p.src
    end

    pipe_chan <+ (next_seqnos * buffer).rights(:src => :src,
                                               :next_seqno => :ident)
    stdio <~ pipe_talk {|p| ["at #{budtime}, pipe_talk has #{p.inspect}"]}
    stdio <~ pipe_chan {|p| ["at #{budtime}, pipe_chan has #{p.inspect}"]}

    next_seqnos <- (next_seqnos * buffer).lefts(:src => :src, 
                                                :next_seqno => :ident)
    next_seqnos <+ (next_seqnos * buffer).lefts(:src => :src, 
                                                :next_seqno => :ident) do 
      |s| [s.src,  s.next_seqno + 1] 
    end

    pipe_sent <= pipe_chan
    buffer <- pipe_chan
  end

  # bloom :remember do
  #   pipe_in <= (buffer * clock).lefts
  # end

  # bloom :send_ack do
  #   ack <~ pipe_talk {|p| [p.src, p.dst, p.ident]}
  # end

  # bloom :done do
  #   msg_acked <= (buffer * ack).lefts(:ident => :ident)
  #   next_seqnos <- (next_seqnos * msg_acked).lefts(:src => :src, 
  #                                                  :next_seqno => :ident)
  #   next_seqnos <+ (next_seqnos * msg_acked).lefts(:src => :src, 
  #                                                  :next_seqno => :ident) do 
  #     |s| [[s.src] => [s.next_seqno + 1]] 
  #   end
  #   pipe_sent <= msg_acked
  #   buffer <- msg_acked
  # end
end
